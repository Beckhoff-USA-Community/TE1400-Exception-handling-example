// ****************** TcComExceptionGenerator.cpp *************************
// Generated by TE140x-TargetForMatlabSimulink  2.8.1.0
// MATLAB 23.2.0.2409890 (R2023b) Update 3 (win64)
// TwinCAT 3.1.0.0
// TwinCAT Target 2.8.1.0
// Beckhoff Automation GmbH & Co. KG     (www.beckhoff.com)
// *************************************************************
#include "TcPch.h"
#pragma hdrstop

#include "TcComExceptionGenerator.h"

#ifdef EXT_MODE
#include "TcExtWork.h"
#endif

#include "ExceptionGenerator.h"

#include "ObjClassFactory.h"
using namespace TcMgSdk;


///////////////////////////////////////////////////////////////////////////////
// Definitions
///////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
#define new DEBUG_NEW
#endif
#if TC_BUILD<=4024
DEFINE_THIS_FILE()
#endif

///////////////////////////////////////////////////////////////////////////////
// CTcComExceptionGenerator specific globals
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// CTcComExceptionGenerator static members
///////////////////////////////////////////////////////////////////////////////
TcMatSim_ModuleGeneratorInfo CTcComExceptionGenerator::m_ModuleGeneratorInfo = {{23,2,0,2409890},{2,8,1,0}};
TcMatSim_SimulinkModelInfo CTcComExceptionGenerator::m_SimulinkModelInfo = {"ExceptionGenerator",{23,2,0,0},{2,5,0,0},{2666700898,200485211,3893975800,242694139}};


///////////////////////////////////////////////////////////////////////////////
// CTcComExceptionGenerator implementation
///////////////////////////////////////////////////////////////////////////////
BEGIN_INTERFACE_MAP(CTcComExceptionGenerator)
INTERFACE_ENTRY_ITCOMOBJECT()
	INTERFACE_ENTRY(IID_ITcPersist,ITcPersist)
	INTERFACE_ENTRY(IID_ITComObject,ITComObject)
	INTERFACE_ENTRY(IID_ITcWatchSource,ITcWatchSource)
	INTERFACE_ENTRY(IID_ITcCyclic,ITcCyclic)
	INTERFACE_ENTRY(IID_ITcPostCyclic,ITcPostCyclic)
	INTERFACE_ENTRY(IID_ITcADI,ITcADI)
	INTERFACE_ENTRY(IID_ITcObjParaAsync,ITcObjParaAsync)
	INTERFACE_ENTRY(IID_ITcExceptionGenerator,ITcExceptionGenerator)
END_INTERFACE_MAP()

IMPLEMENT_ITCWATCHSOURCE(CTcComExceptionGenerator)

BEGIN_OBJDATAAREA_MAP(CTcComExceptionGenerator)
	OBJDATAAREA_PTR_SIZE(0, &(ExceptionGenerator_Obj.ExceptionGenerator_U.DivByZero), 2)
	OBJDATAAREA_PTR_SIZE(1, &(ExceptionGenerator_Obj.ExceptionGenerator_Y.Result), 16)
	OBJDATAAREA_PTR_SIZE(2, &(ExceptionGenerator_Obj.ExceptionGenerator_DW.Counter), 40)
	OBJDATAAREA_PTR_SIZE(3, &m_ContextInfo[0].Execution, sizeof(m_ContextInfo[0].Execution))
END_OBJDATAAREA_MAP()

BEGIN_SETOBJPARA_MAP2(CTcComExceptionGenerator,TcMatSim::GeneratedTcCom)
	SETOBJPARA_DATAAREA_MAP()
	SETOBJPARA_VALUE(0x00000001, m_TraceLevelMax)
	SETOBJPARA_VALUE_LOCK(0x00000002, m_ModuleCaller, -1, VarAccess(Access::ReadWrite,Access::ReadWrite,Access::ReadWrite,Access::Read))
	SETOBJPARA_VALUE(0x00000003, m_CallerVerification)
	SETOBJPARA_VALUE_LOCK(0x00000004, m_StepSizeAdaptation, -1, VarAccess(Access::ReadWrite,Access::ReadWrite,Access::Read,Access::Read))
	SETOBJPARA_VALUE_LOCK(0x00000005, m_ExecutionSequence, -1, VarAccess(Access::ReadWrite,Access::ReadWrite,Access::ReadWrite,Access::Read))
	SETOBJPARA_VALUE(0x00000006, m_Execute)
	SETOBJPARA_VALUE_LOCK(0x00000007, m_AccessLockState, -1, VarAccess(Access::ReadWrite,Access::ReadWrite,Access::ReadWrite,Access::Read))
	SETOBJPARA_VALUE(0x00000008, GetFpExceptCtrlSet(TcMgSdk::FpCtrlSection::Init))
	SETOBJPARA_VALUE(0x00000009, GetFpExceptCtrlSet(TcMgSdk::FpCtrlSection::Update))
	SETOBJPARA_VALUE_DENIED(0x0000000a, m_ModuleBuildInfo)
	SETOBJPARA_VALUE_DENIED(0x0000000b, m_Initialized)
	SETOBJPARA_VALUE_DENIED(0x0000000c, m_ContextInfo.SkippedExecutionCount())
	SETOBJPARA_VALUE_DENIED(0x0000000d, GetLibraryInfo())
	SETOBJPARA_VALUE_DENIED(0x0000000e, GetModuleInfo())
	SETOBJPARA_VALUE_DENIED(0x0000000f, m_ModuleGeneratorInfo)
	SETOBJPARA_VALUE_DENIED(0x00000010, m_SimulinkModelInfo)
	SETOBJPARA_VALUE_DENIED(0x00000011, &m_ContextInfo[0].Execution.CycleCount)
	SETOBJPARA_VALUE_DENIED(0x00000012, &m_ContextInfo[0].Execution.ExceptionCount)
	SETOBJPARA_VALUE_DENIED(0x00000013, &m_ContextInfo[0].Execution.ActException)
END_SETOBJPARA_MAP2(TcMatSim::GeneratedTcCom)

BEGIN_GETOBJPARA_MAP2(CTcComExceptionGenerator,TcMatSim::GeneratedTcCom)
	GETOBJPARA_DATAAREA_MAP()
	GETOBJPARA_VALUE(0x00000001, m_TraceLevelMax)
	GETOBJPARA_VALUE(0x00000002, m_ModuleCaller)
	GETOBJPARA_VALUE(0x00000003, m_CallerVerification)
	GETOBJPARA_VALUE(0x00000004, m_StepSizeAdaptation)
	GETOBJPARA_VALUE(0x00000005, m_ExecutionSequence)
	GETOBJPARA_VALUE(0x00000006, m_Execute)
	GETOBJPARA_VALUE(0x00000007, m_AccessLockState)
	GETOBJPARA_VALUE(0x00000008, GetFpExceptCtrlSet(TcMgSdk::FpCtrlSection::Init))
	GETOBJPARA_VALUE(0x00000009, GetFpExceptCtrlSet(TcMgSdk::FpCtrlSection::Update))
	GETOBJPARA_VALUE(0x0000000a, m_ModuleBuildInfo)
	GETOBJPARA_VALUE(0x0000000b, m_Initialized)
	GETOBJPARA_VALUE(0x0000000c, m_ContextInfo.SkippedExecutionCount())
	GETOBJPARA_VALUE(0x0000000d, GetLibraryInfo())
	GETOBJPARA_VALUE(0x0000000e, GetModuleInfo())
	GETOBJPARA_VALUE(0x0000000f, m_ModuleGeneratorInfo)
	GETOBJPARA_VALUE(0x00000010, m_SimulinkModelInfo)
	GETOBJPARA_PTR_SIZE(0x00000011, &m_ContextInfo[0].Execution.CycleCount, sizeof(m_ContextInfo[0].Execution.CycleCount))
	GETOBJPARA_PTR_SIZE(0x00000012, &m_ContextInfo[0].Execution.ExceptionCount, sizeof(m_ContextInfo[0].Execution.ExceptionCount))
	GETOBJPARA_PTR_SIZE(0x00000013, &m_ContextInfo[0].Execution.ActException, sizeof(m_ContextInfo[0].Execution.ActException))
END_GETOBJPARA_MAP2(TcMatSim::GeneratedTcCom)

BEGIN_OBJPARAWATCH_MAP2(CTcComExceptionGenerator)
	OBJPARAWATCH_DATAAREA_MAP()
	OBJPARAWATCH_VALUE(0x00000001, m_TraceLevelMax)
	OBJPARAWATCH_VALUE(0x00000002, m_ModuleCaller)
	OBJPARAWATCH_VALUE(0x00000003, m_CallerVerification)
	OBJPARAWATCH_VALUE(0x00000004, m_StepSizeAdaptation)
	OBJPARAWATCH_VALUE(0x00000005, m_ExecutionSequence)
	OBJPARAWATCH_VALUE(0x00000006, m_Execute)
	OBJPARAWATCH_VALUE(0x00000007, m_AccessLockState)
	OBJPARAWATCH_VALUE(0x00000008, GetFpExceptCtrlSet(TcMgSdk::FpCtrlSection::Init))
	OBJPARAWATCH_VALUE(0x00000009, GetFpExceptCtrlSet(TcMgSdk::FpCtrlSection::Update))
	OBJPARAWATCH_VALUE(0x0000000a, m_ModuleBuildInfo)
	OBJPARAWATCH_VALUE(0x0000000b, m_Initialized)
	OBJPARAWATCH_VALUE(0x0000000c, m_ContextInfo.SkippedExecutionCount())
	OBJPARAWATCH_VALUE(0x0000000d, GetLibraryInfo())
	OBJPARAWATCH_VALUE(0x0000000e, GetModuleInfo())
	OBJPARAWATCH_VALUE(0x0000000f, m_ModuleGeneratorInfo)
	OBJPARAWATCH_VALUE(0x00000010, m_SimulinkModelInfo)
	OBJPARAWATCH_PTR_SIZE(0x00000011, &m_ContextInfo[0].Execution.CycleCount, sizeof(m_ContextInfo[0].Execution.CycleCount))
	OBJPARAWATCH_PTR_SIZE(0x00000012, &m_ContextInfo[0].Execution.ExceptionCount, sizeof(m_ContextInfo[0].Execution.ExceptionCount))
	OBJPARAWATCH_PTR_SIZE(0x00000013, &m_ContextInfo[0].Execution.ActException, sizeof(m_ContextInfo[0].Execution.ActException))
END_OBJPARAWATCH_MAP2(TcMatSim::GeneratedTcCom)

IMPLEMENT_ITCADI(CTcComExceptionGenerator)

IMPLEMENT_IPERSIST_LIB(CTcComExceptionGenerator,VID_ExceptionGenerator,CID_EXCEPTIONGENERATOR)

IMPLEMENT_GETMODULEINFO(CTcComExceptionGenerator,ExceptionGenerator,CID_EXCEPTIONGENERATOR,VID_ExceptionGenerator)

BEGIN_OBJPARAASYNC_MAP2(CTcComExceptionGenerator,TcMatSim::GeneratedTcCom)
	OBJPARAASYNC_VALUE(0x00000001, m_TraceLevelMax)
	OBJPARAASYNC_VALUE_LOCK(0x00000002, m_ModuleCaller, -1, VarAccess(Access::ReadWrite,Access::ReadWrite,Access::ReadWrite,Access::Read))
	OBJPARAASYNC_VALUE(0x00000003, m_CallerVerification)
	OBJPARAASYNC_VALUE_LOCK(0x00000004, m_StepSizeAdaptation, -1, VarAccess(Access::ReadWrite,Access::ReadWrite,Access::Read,Access::Read))
	OBJPARAASYNC_VALUE_LOCK(0x00000005, m_ExecutionSequence, -1, VarAccess(Access::ReadWrite,Access::ReadWrite,Access::ReadWrite,Access::Read))
	OBJPARAASYNC_VALUE(0x00000006, m_Execute)
	OBJPARAASYNC_VALUE_LOCK(0x00000007, m_AccessLockState, -1, VarAccess(Access::ReadWrite,Access::ReadWrite,Access::ReadWrite,Access::Read))
	OBJPARAASYNC_VALUE(0x00000008, GetFpExceptCtrlSet(TcMgSdk::FpCtrlSection::Init))
	OBJPARAASYNC_VALUE(0x00000009, GetFpExceptCtrlSet(TcMgSdk::FpCtrlSection::Update))
	OBJPARAASYNC_VALUE_LOCK(0x0000000a, m_ModuleBuildInfo, -1, VarAccess(Access::Read))
	OBJPARAASYNC_VALUE_LOCK(0x0000000b, m_Initialized, -1, VarAccess(Access::Read))
	OBJPARAASYNC_VALUE_LOCK(0x0000000c, m_ContextInfo.SkippedExecutionCount(), -1, VarAccess(Access::Read))
	OBJPARAASYNC_VALUE_LOCK(0x0000000d, GetLibraryInfo(), -1, VarAccess(Access::Read))
	OBJPARAASYNC_VALUE_LOCK(0x0000000e, GetModuleInfo(), -1, VarAccess(Access::Read))
	OBJPARAASYNC_VALUE_LOCK(0x0000000f, m_ModuleGeneratorInfo, -1, VarAccess(Access::Read))
	OBJPARAASYNC_VALUE_LOCK(0x00000010, m_SimulinkModelInfo, -1, VarAccess(Access::Read))
	OBJPARAASYNC_PTR_SIZE_LOCK(0x00000011, &m_ContextInfo[0].Execution.CycleCount, sizeof(m_ContextInfo[0].Execution.CycleCount), -1, VarAccess(Access::Read))
	OBJPARAASYNC_PTR_SIZE_LOCK(0x00000012, &m_ContextInfo[0].Execution.ExceptionCount, sizeof(m_ContextInfo[0].Execution.ExceptionCount), -1, VarAccess(Access::Read))
	OBJPARAASYNC_PTR_SIZE_LOCK(0x00000013, &m_ContextInfo[0].Execution.ActException, sizeof(m_ContextInfo[0].Execution.ActException), -1, VarAccess(Access::Read))
END_OBJPARAASYNC_MAP2(TcMatSim::GeneratedTcCom)

// State transition: Init -> PreOp
HRESULT CTcComExceptionGenerator::SetObjStateIP(ITComObjectServer* ipSrv, TComInitDataHdr* pInitData)
{
	HRESULT hr = S_OK;

	if (SUCCEEDED(hr))
		hr = SingleInstanceLock(GUID_NULL);
	if (SUCCEEDED(hr))
	{
		m_ContextInfo[0].OriginalTid = 0;
		m_ContextInfo[0].OriginalSampleTime = 0.01;

	}
	if (SUCCEEDED(hr))
	{

	}
	if (FAILED(hr))
	{
		SetObjStatePI();
	}
	return hr;
}

// State transition: PreOp -> SafeOp
HRESULT CTcComExceptionGenerator::SetObjStatePS(TComInitDataHdr* pInitData)
{
	HRESULT hr = S_OK;


	if(SUCCEEDED(hr))
	{
		auto fpCtrl = FpControl(FpCtrlSection::Init);
		ExceptionGenerator_Obj.initialize();

		if (SUCCEEDED(hr))
			hr = CheckAndAdaptCycleTimes();
		m_Initialized = SUCCEEDED(hr);
		FpRestore(fpCtrl);
	}

	if (FAILED(hr))
	{
		SetObjStateSP();
	}
	return hr;
}

// State transition: SafeOp -> Op
HRESULT CTcComExceptionGenerator::SetObjStateSO()
{
	HRESULT hr = S_OK;

	if (FAILED(hr))
	{
		SetObjStateOS();
	}
	return hr;
}

// State transition: Op -> SafeOp
HRESULT CTcComExceptionGenerator::SetObjStateOS()
{
	HRESULT hr = S_OK;

	return hr;
}

// State transition: SafeOp -> PreOp
HRESULT CTcComExceptionGenerator::SetObjStateSP()
{
	HRESULT hr = S_OK;

	auto fpCtrl = FpControl(FpCtrlSection::Init);
	FpRestore(fpCtrl);

	m_Initialized = false;

	return hr;
}

// State transition: PreOp -> Init
HRESULT CTcComExceptionGenerator::SetObjStatePI()
{
	HRESULT hr = S_OK;

	auto fpCtrl = FpControl(FpCtrlSection::Init);
	ExceptionGenerator_Obj.terminate();

	FpRestore(fpCtrl);
	SingleInstanceRelease();

	return hr;
}

// Constructor
CTcComExceptionGenerator::CTcComExceptionGenerator() :
	TcMatSim::GeneratedTcCom(1,0,TC_BUILD_MIN,0)
{
	m_TraceLevelMax = tlInfo;
	m_ModuleCaller = ModuleCaller::CyclicTask;
	m_CallerVerification = CallerVerification::Default;
	m_StepSizeAdaptation = StepSizeAdaptation::RequireMatchingTaskCycleTime;
	m_ExecutionSequence = ExecutionSequence2::UpdateBeforeOutputMapping;
	m_Execute = false;
	m_AccessLockState = TCOM_STATE_OP;
	GetFpExceptCtrlSet(TcMgSdk::FpCtrlSection::Init) = FpExcptCtrlSet::Prec53_CallerExceptions;
	GetFpExceptCtrlSet(TcMgSdk::FpCtrlSection::Update) = FpExcptCtrlSet::Prec53_LogCatchAndDump;
	m_Initialized = 0;
	m_ContextInfo.SkippedExecutionCount() = 0;

#ifdef _DEBUG
	m_ModuleBuildInfo.Debug = true;
#else
	m_ModuleBuildInfo.Debug = false;
#endif
	m_ModuleBuildInfo.TcBuild = TC_BUILD;
	m_ModuleBuildInfo.TcRevision = TC_REVISION;

}

// Destructor
CTcComExceptionGenerator::~CTcComExceptionGenerator()
{

}

HRESULT TCOMAPI CTcComExceptionGenerator::CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context)
{

	if (!m_Execute)
		return S_FALSE;
	if (!m_Initialized)
		return ADS_E_NOTINIT;
	if (m_ExecutionSequence!=TcMgSdk::ExecutionSequence2::UpdateBeforeOutputMapping)
		return S_OK;
	m_ContextInfo[context].ExecutingCyclicCall = true;
	HRESULT hr = Update(ipTask, context);
	m_ContextInfo[context].ExecutingCyclicCall = false;
	return hr;
}

HRESULT TCOMAPI CTcComExceptionGenerator::PostCyclicUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context)
{

	if (!m_Execute)
		return S_FALSE;
	if (!m_Initialized)
		return ADS_E_NOTINIT;
	if (m_ExecutionSequence!=TcMgSdk::ExecutionSequence2::IoAtTaskBegin)
		return S_OK;
	m_ContextInfo[context].ExecutingPostCyclicCall = true;
	HRESULT hr = Update(ipTask, context);
	m_ContextInfo[context].ExecutingPostCyclicCall = false;
	return hr;
}

HRESULT CTcComExceptionGenerator::Update(ITcTask* ipTask, ULONG_PTR context)
{
	HRESULT hr = SynchronizeTasks(context);
	if(SUCCEEDED(hr))
		hr = VerifyCaller(ipTask, context);

	if(SUCCEEDED(hr) && m_ContextInfo[context].Synchronized)
	{
		auto fpCtrl = FpControl(FpCtrlSection::Update);
		TcTry
		{
			hr = EvalMdlErrorStatus(ExceptionGenerator_Obj.getRTM()->errorStatus,false);
			if (hr == S_OK)
			{
				ExceptionGenerator_Obj.step();
				EvalMdlErrorStatus(ExceptionGenerator_Obj.getRTM()->errorStatus,true);
			}

		}
		TcExcept(ExceptionFilter(ipTask, GetExceptionInformation(), static_cast<LONG>(context)))
		{
			ExceptionHandler();
		}
		FpRestore(fpCtrl);
		m_ContextInfo.IncrementCaller(context);
	}

	return hr;

}

HRESULT CTcComExceptionGenerator::CheckAndAdaptCycleTimes()
{
	double fCycleTimeMultiplier = 1;
	HRESULT hr = CheckCycleTimes(fCycleTimeMultiplier);
	return hr;
}

// ITcExceptionGenerator
HRESULT TCOMAPI CTcComExceptionGenerator::step()
{
	HRESULT hr = S_OK;
	auto fpCtrl = FpControl(FpCtrlSection::Update);

	ExceptionGenerator_Obj.step();


	FpRestore(fpCtrl);
	return hr;
}




HRESULT TCOMAPI Create_CTcComExceptionGenerator (PITCID pIid, PPVOID pipItf)
{
	return Create<CTcComExceptionGenerator>(*pIid, pipItf);
}
